C51 COMPILER V9.60.0.0   1602_CHUANKOU                                                     04/25/2022 02:57:38 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE 1602_CHUANKOU
OBJECT MODULE PLACED IN 1602-chuankou.OBJ
COMPILER INVOKED BY: D:\Keil\C51\BIN\C51.EXE 1602-chuankou.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          /*********************************************************************************
   2          * 【编写时间】： 2014年3月5日
   3          * 【作    者】： 清翔电子:03
   4          * 【版    本】： 1.0
   5          * 【网    站】： http://www.qxmcu.com/ 
   6          * 【淘宝店铺】： http://qxmcu.taobao.com/ 
   7          * 【实验平台】： QX-MCS51 单片机开发板
   8          * 【外部晶振】： 11.0592mhz 
   9          * 【主控芯片】： STC89C52
  10          * 【编译环境】： Keil μVisio3  
  11          * 【程序功能】：                                    
  12          * 【使用说明】： 液晶1脚接1602黑色排母的1脚  如果是无背光的液晶只有14个脚 排母右边空2个位   
  13                           请把液晶对比度电位器顺时针调制10点钟方向，请勿多调超出极限位置会损坏电位器！
  14          *  说明：免费开源，不提供源代码分析.
  15          **********************************************************************************/
  16           
  17          /************************************************************************
  18          * 描述：（用串口调试助手软件观察）                                      
  19          *   主机发送0123456789abcdef给单片机，单片机接收到数据后发送QX-MCU789abcdef给主机。   
  20          *   LCD1602上显示    0123456789abcdef 
  21          *   LCD1602显示接收数据的ASCII码。  波特率9600    发送和接收都要选择为文本格式                  
  22          *   注：当单片机收到数据只有凑够16个时才会一次在液晶上显示出来        
  23          ************************************************************************/
  24          
  25          #include <reg52.h>
  26          #include <intrins.h>
  27            
  28          #define uchar  unsigned char 
  29          #define uint   unsigned int
  30          
  31          sbit LCD_RS = P3^5;
  32          sbit LCE_RW = P3^6;             
  33          sbit LCD_EN = P3^4;
  34          
  35          unsigned char pwm_motor_val = 254;//左右电机占空比值 取值范围0-170，0最快
  36          unsigned char pwm_t;//周期
  37          
  38          sbit _4IN = P1^0;//
  39          sbit BIN = P1^1;//
  40          sbit key_s2 = P3^2;
  41          sbit key_s3 = P3^3;
  42          
  43          #define delayNOP(); {_nop_();_nop_();_nop_();_nop_();};
  44          
  45          
  46          
  47          
  48          
  49          uchar data  RXDdata[ ] = {0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
  50                                    0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20 };
  51          uchar temp,buf,m,count;
  52          
  53          bit   playflag=0;
  54          
  55          uchar code  cdis1[ ] = {" SERILA TRANFER "};
C51 COMPILER V9.60.0.0   1602_CHUANKOU                                                     04/25/2022 02:57:38 PAGE 2   

  56          uchar code  cdis2[ ] = {"                "};
  57          
  58          void delay(unsigned int z)//毫秒级延时
  59          {
  60   1        unsigned int x,y;
  61   1        for(x = z; x > 0; x--)
  62   1          for(y = 114; y > 0 ; y--);
  63   1      }
  64          /**********************************************************
  65          
  66           延时子程序
  67          
  68          **********************************************************/
  69          void delay1(uint ms) 
  70          
  71          {
  72   1         uchar k;
  73   1         while(ms--)
  74   1         {
  75   2           for(k = 0; k < 120; k++);
  76   2         }
  77   1      }
  78          
  79          /*******************************************************************/
  80          /*                                                                 */
  81          /*写指令数据到LCD                                                  */
  82          /*RS=L，RW=L，E=高脉冲，D0-D7=指令码。                             */
  83          /*                                                                 */
  84          /*******************************************************************/
  85          void lcd_wcmd(uchar cmd)
  86          {                          
  87   1       //  while(lcd_busy());
  88   1          LCD_RS = 0;
  89   1        //  LCD_RW = 0;
  90   1          LCD_EN = 0;
  91   1          _nop_();
  92   1          _nop_(); 
  93   1          P0 = cmd;
  94   1          delayNOP();
  95   1          LCD_EN = 1;
  96   1          delayNOP();
  97   1          LCD_EN = 0;  
  98   1      }
  99          
 100          /*******************************************************************/
 101          /*                                                                 */
 102          /*写显示数据到LCD                                                  */
 103          /*RS=H，RW=L，E=高脉冲，D0-D7=数据。                               */
 104          /*                                                                 */
 105          /*******************************************************************/
 106          void lcd_wdat(uchar dat)
 107          {                          
 108   1      //   while(lcd_busy());
 109   1          LCD_RS = 1;
 110   1        //  LCD_RW = 0;
 111   1          LCD_EN = 0;
 112   1          P0 = dat;
 113   1          delayNOP();
 114   1          LCD_EN = 1;
 115   1          delayNOP();
 116   1          LCD_EN = 0; 
 117   1      }
C51 COMPILER V9.60.0.0   1602_CHUANKOU                                                     04/25/2022 02:57:38 PAGE 3   

 118          
 119          /*******************************************************************/
 120          /*                                                                 */
 121          /*  LCD初始化设定                                                  */
 122          /*                                                                 */
 123          /*******************************************************************/
 124          void lcd_init()
 125          { 
 126   1           LCE_RW = 0; 
 127   1          delay1(15);   
 128   1          lcd_wcmd(0x01);      //清除LCD的显示内容            
 129   1          lcd_wcmd(0x38);      //16*2显示，5*7点阵，8位数据
 130   1          delay1(5);
 131   1          lcd_wcmd(0x38);         
 132   1          delay1(5);
 133   1          lcd_wcmd(0x38);         
 134   1          delay1(5);
 135   1      
 136   1          lcd_wcmd(0x0c);      //开显示，显示光标，光标闪烁
 137   1          delay1(5);
 138   1      
 139   1          lcd_wcmd(0x01);      //清除LCD的显示内容
 140   1          delay1(5);
 141   1      }
 142          
 143          /*******************************************************************/
 144          /*                                                                 */
 145          /*  设定显示位置                                                   */
 146          /*                                                                 */
 147          /*******************************************************************/
 148          
 149          void lcd_pos(uchar pos)
 150          {                          
 151   1        lcd_wcmd(pos | 0x80);  //数据指针=80+地址变量
 152   1      }
 153          
 154          
 155          /*********************************************************
 156          
 157            串行中断服务函数
 158          
 159          *********************************************************/
 160          void  serial() interrupt 4 
 161          {
 162   1         ES = 0;                //关闭串行中断
 163   1         RI = 0;                //清除串行接受标志位
 164   1         buf = SBUF;            //从串口缓冲区取得数据
 165   1           
 166   1      //   switch(buf)
 167   1      //   {
 168   1      //      case 0x01:  senddata('1');wen=1;break;  //接受到1，发送字符'Q'给计算机         
 169   1      //      case 0x02:  senddata('2');wen=2;break;  //接受到2，发送字符'X'给计算机       
 170   1      //      case 0x03:  senddata('3');wen=3;break;  //接受到3，发送字符'-'给计算机       
 171   1      //      case 0x04:  senddata('4');wen=4;break;  //接受到4，发送字符'M'给计算机       
 172   1      //      case 0x05:  senddata('5');wen=5;break;  //接受到5，发送字符'C'给计算机           
 173   1      //      case 0x06:  senddata('6');wen=6;break;  //接受到5，发送字符'U'给计算机
 174   1      //      case 0x07:  senddata('7');wen=7;break;  //接受到1，发送字符'Q'给计算机         
 175   1      //      case 0x08:  senddata('8');wen=8;break;  //接受到2，发送字符'X'给计算机       
 176   1      //      case 0x09:  senddata('9');wen=9;break;  //接受到3，发送字符'-'给计算机       
 177   1      //      case 0x00:  senddata('0');wen=0;break;  //接受到4，发送字符'M'给计算机             
 178   1      //      default:    senddata(buf);wen=0;break;  //接受到其它数据，将其发送给计算机         
 179   1      //   }
C51 COMPILER V9.60.0.0   1602_CHUANKOU                                                     04/25/2022 02:57:38 PAGE 4   

 180   1      //   if(wen_wei==0)
 181   1      //   {
 182   1      //     
 183   1      //     z_wen=wen*10;
 184   1      //     wen_wei=1;
 185   1      //     
 186   1      //   }else{
 187   1      //     //30  0   90 255
 188   1      //    pwm_motor_val=-3.22*(wen+z_wen)+190.6;    
 189   1      //      wen_wei=0;
 190   1      //   }
 191   1      
 192   1      
 193   1         if(buf!=0x0D)
 194   1         {   
 195   2           if(buf!=0x0A)
 196   2           { 
 197   3             temp =buf;
 198   3             if(count<2)
 199   3             {         
 200   4               RXDdata[count]=temp;
 201   4               count++;
 202   4           if(count==2)
 203   4            playflag=1;
 204   4             }
 205   3           } 
 206   2         }
 207   1         ES = 1;    //允许串口中断
 208   1      }
 209          int wen=0;
 210          int wen_1=0;
 211          int i=0;
 212          /*********************************************************
 213          
 214            数据显示函数
 215          
 216          *********************************************************/
 217          void  play()
 218          {
 219   1         if(playflag)
 220   1         { 
 221   2           lcd_pos(0x40);           //设置位置为第二行
 222   2           for(m=0;m<2;m++) 
 223   2           {
 224   3          lcd_wdat(cdis2[m]);      //清LCD1602第二行
 225   3          delay1(5);
 226   3         }
 227   2         lcd_pos(0x40);           //设置位置为第二行
 228   2           for(m=0;m<2;m++)
 229   2           {
 230   3             wen=(int)RXDdata[m];
 231   3             
 232   3             if(m==0)
 233   3             {
 234   4               wen_1=wen*10;
 235   4      
 236   4             }else if(m==1){
 237   4               pwm_motor_val=(int)(255-2.4*(wen_1+wen));
 238   4            
 239   4             }
 240   3          //   lcd_pos(0x40+m);       //设置显示位置为第二行
 241   3             lcd_wdat(wen);  //显示字符 
C51 COMPILER V9.60.0.0   1602_CHUANKOU                                                     04/25/2022 02:57:38 PAGE 5   

 242   3           delay1(5);
 243   3           }
 244   2      
 245   2           playflag=0;              
 246   2           count=0x00;
 247   2      
 248   2           for(m=0;m<2;m++)      
 249   2           {
 250   3          RXDdata[m]=0x20;         //清显存单元    
 251   3          delay1(5);
 252   3         }
 253   2         }               
 254   1      }
 255          
 256          /*********************************************************
 257          
 258            主函数
 259          
 260          *********************************************************/
 261          void main(void) 
 262          {
 263   1          P0 = 0xff;
 264   1          P2 = 0xff;         
 265   1          
 266   1          SCON=0x50;           //设定串口工作方式
 267   1          PCON=0x00;           //波特率不倍增
 268   1            
 269   1          TMOD=0x20;           //定时器1工作于8位自动重载模式, 用于产生波特率
 270   1          EA=1;
 271   1          ES = 1;              //允许串口中断
 272   1          TL1=0xfd;
 273   1          TH1=0xfd;             //波特率9600
 274   1          TR1=1;
 275   1        
 276   1        //PWM
 277   1          TMOD |= 0x02;//8位自动重装模块
 278   1          TH0 = 220;
 279   1          TL0 = 220;//11.0592M晶振下占空比最大比值是256,输出100HZ
 280   1          TR0 = 1;//启动定时器0
 281   1          ET0 = 1;//允许定时器0中断
 282   1          EA  = 1;//总中断允许
 283   1        
 284   1        
 285   1          lcd_init();
 286   1          lcd_pos(0x00);        //设置显示位置为第一行
 287   1          for(m=0;m<16;m++) 
 288   1          {
 289   2          lcd_wdat(cdis1[m]);   //显示字符
 290   2          delay1(5);
 291   2        }
 292   1          lcd_pos(0x40);        //设置显示位置为第二行
 293   1          for(m=0;m<16;m++) 
 294   1          {
 295   2          lcd_wdat(cdis2[m]);   //显示字符            
 296   2          delay1(5);
 297   2        }
 298   1          BIN=0;
 299   1          while(1)        
 300   1          {
 301   2            play();     
 302   2            
 303   2          if(key_s2 == 0)  //S2按下LED变暗
C51 COMPILER V9.60.0.0   1602_CHUANKOU                                                     04/25/2022 02:57:38 PAGE 6   

 304   2          {
 305   3            delay(5);
 306   3            if(key_s2 == 0)
 307   3            {
 308   4              if(pwm_motor_val < 254)
 309   4              {
 310   5                pwm_motor_val++;
 311   5              }
 312   4            }
 313   3          }
 314   2          if(key_s3 == 0) //S3按键LED变亮
 315   2          {
 316   3            delay(5);
 317   3            if(key_s3 == 0)
 318   3            {
 319   4              if(pwm_motor_val > 0)
 320   4              {
 321   5                pwm_motor_val--;
 322   5              }
 323   4            }
 324   3          }     
 325   2          }
 326   1      }
 327          
 328          //定时器0中断
 329          void timer0() interrupt 1
 330          {
 331   1        pwm_t++;
 332   1        if(pwm_t == 255)
 333   1          _4IN = 0;
 334   1        if(pwm_motor_val == pwm_t)
 335   1          _4IN = 1;          
 336   1      }
 337          /*********************************************************/ 


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    610    ----
   CONSTANT SIZE    =     34    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     28    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
